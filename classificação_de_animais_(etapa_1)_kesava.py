# -*- coding: utf-8 -*-
"""Classificação De Animais (Etapa 1) - kesava.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16tU5EhkRCgN55YZ3zOylyTVJW-rQThlp

# **Projeto de Classificação de Animais - Etapa 1**

## **1. Instalação das bibliotecas necessárias**
"""

# Instalação de pacotes necessários

!pip install opendatasets
!pip install pandas
!pip install imagehash

"""## **2. Baixando o conjunto de dados do [Kaggle](https://www.kaggle.com/datasets/anthonytherrien/image-classification-64-classes-animal)**"""

# Baixando o conjunto de dados

import opendatasets as od

od.download("https://www.kaggle.com/datasets/anthonytherrien/image-classification-64-classes-animal")

# Processamento e Análise de Dados

!ls

"""## **3. Criar um Dataframe com os metadados das imagens**"""

# Commented out IPython magic to ensure Python compatibility.
# Importação de bibliotecas para processamento de imagens, manipulação de dados e visualização

import cv2
import os
import imagehash
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
from PIL import Image
from concurrent.futures import ProcessPoolExecutor

# Listas para armazenar dados sobre imagens corrompidas e dados processados

corrupted = []
df_list = []

# Diretório raiz das imagens para classificação de animais

root_dir = '/content/image-classification-64-classes-animal/image/'

# Função para processar imagens e extrair informações

def process_image(image_path, animal):
    if not os.path.isfile(image_path):
        return [image_path, True, None, None, None, None, None, animal]

    img = cv2.imread(image_path)
    if img is None:
        return [image_path, True, None, None, None, None, None, animal]

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_pil = Image.fromarray(img_rgb)
    img_hash = imagehash.phash(img_pil)
    width, height, channels = img.shape
    image_format = os.path.splitext(image_path)[-1]

    return [image_path, False, img_hash, image_format, width, height, channels, animal]

# Função para processar todas as imagens de um diretório específico de animais

def process_animal(animal_dir, animal):
    image_paths = [os.path.join(animal_dir, image) for image in os.listdir(animal_dir) if os.path.isfile(os.path.join(animal_dir, image))]

    with ProcessPoolExecutor() as executor:
        results = executor.map(process_image, image_paths, [animal] * len(image_paths))

    valid_results = []
    for result in results:
        if result:
            if result[1]:
                corrupted.append(result[0])
            valid_results.append(result)
    return valid_results

# Processamento Paralelo de Diretórios de Imagens de Animais

for animal in os.listdir(root_dir):
    animal_dir = os.path.join(root_dir, animal)
    if os.path.isdir(animal_dir):
        results = process_animal(animal_dir, animal)
        df_list.extend(results)

# Relatório de Imagens Corrompidas no Dataset

print(f'Total de Imagens Corrompidas: {len(corrupted)}\n'
      f'Imagens corrompidas:\n{corrupted}')

# Criação de DataFrame com os resultados do processamento de imagens

df = pd.DataFrame(columns=['image_path', 'corrupted', 'image_hash', 'image_format', 'width', 'height', 'channels', 'label'], data = df_list)
df.head()

"""## **4. Verificação da Integridade dos arquivos**"""

# Estatísticas Descritivas das Imagens Processadas

df.describe().loc[['mean', 'std', 'min', 'max']]

# Distribuição de Imagens por Formato

df['image_format'].value_counts().plot(kind='bar', title='Number of images per format')
plt.xticks(rotation=0)

"""## **5. Verificação da Consistência dos Metadados**"""

# Verificando se há valores discrepantes em termos de dimensão das imagens, utilizando o data frame criado

plt.scatter(df['width'], df['height'])

# Verificando se há campos nulos no data frame

df.isnull().sum()

"""## **6. Analisando a Qualidade das Imagens**"""

# Contagem Total de Imagens Corrompidas

df['corrupted'].sum()

# Distribuição de Imagens Corrompidas e Não Corrompidas

df['corrupted'].value_counts()

"""## **7. Verificação da Distribuição de Classes**"""

# Distribuição das Classes de Animais no Dataset

class_distribution = df['label'].value_counts()
print(class_distribution)

class_distribution.plot(kind='bar', figsize=(12, 6))
plt.title('Distribuição das Classes')
plt.xlabel('Animal')
plt.ylabel('Quantidade')

plt.xticks(rotation=45, ha='right', fontsize=8)  #Rotacionar os rótulos e ajustar o tamanho da fonte

plt.tight_layout()  #Ajustar o layout para evitar sobreposição de rótulos
plt.show()

# Exibição de Imagens de Teste para Cada Rótulo de Classe

unique_labels = df['label'].unique()

#Itera por cada rótulo único
for label in unique_labels:
    #Filtra o dataframe para o rótulo atual
    subset = df[df['label'] == label]

    #Seleciona os caminhos das duas primeiras imagens(Usando as duas primeiras imagens como teste)
    image_paths = subset['image_path'].head(2).tolist()

    # Cria uma figura e eixos para as imagens
    fig, axes = plt.subplots(1, 2, figsize=(10, 5))

    for i, image_path in enumerate(image_paths):
        img = plt.imread(image_path)
        axes[i].imshow(img)
        axes[i].set_title(label)
        axes[i].axis('off')

    plt.tight_layout()
    plt.show()

"""## **8. Verificando a Presença de Duplicatas**"""

# Quantidade de imagens duplicatas

df['image_hash'].duplicated().sum()